from parsing.instantiators import instantiate_rules
from exceptions import InvalidLogicException
from random import choice
import logging

class BaseTypeFuzzer():
    def __init__(self, rules=None, rule_closures=None, argname=None, **kwargs):
        self.rules = instantiate_rules(rules, str(self), self) if rules is not None else []
        possible_rules = [closure(self, **kwargs) for closure in rule_closures]
        self.rules += [rule for rule in possible_rules if argname in rule.related_args]
        self.rules.sort(key=lambda rule: rule.loc)

        self.argname = argname

        # Delay the application to the fuzzer to accurately point out impossible logical constraints
        self.apply_rules()

    def apply_rules(self):
        for rule in self.rules:
            rule.apply_to(self)
            if self.empty_set():
                logging.error(f"\tConstraints applied to fuzzer {self} are impossible to satisfy. The rule that caused this was {rule}.")
                raise InvalidLogicException(self.constraints_to_str())

    def next_valid(self):
        value = self.next()

        logging.debug(f"Fuzzer ({self.pretty_str()}) generated value {value}.")

        # Throws if invalid
        self.validate(value)

        return value

    def pretty_str(self):
        return f"{self} {self.argname}"

    def constraints_to_str(self):
        """Prints the solidity type this fuzzer generates"""
        raise NotImplementedError(f"Subclass {type(self).__name__} must override constraints_to_str")

    def __str__(self):
        """Prints the solidity type this fuzzer generates"""
        raise NotImplementedError(f"Subclass {type(self).__name__} must override __str__")

    def validate(self, value):
        """Validates a value generated by a rule"""
        raise NotImplementedError(f"Subclass {type(self).__name__} must override validate")
    
    def next(self):
        """Generates a new random value, without any generation rules"""
        raise NotImplementedError(f"Subclass {type(self).__name__} must override next")
    
    def empty_set(self):
        """Returns true if the set of possible values is empty"""
        raise NotImplementedError(f"Subclass {type(self).__name__} must override empty_set")
